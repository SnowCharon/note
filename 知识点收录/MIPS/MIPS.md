## 常用指令
1. **加法指令详解**
    
    - `ADD` 指令：格式 `ADD $dest, $src1, $src2`
        
        - 作用：将 `$src1` 和 `$src2` 的值相加并将结果存储在 `$dest`。
        - 例子：`ADD $t0, $t1, $t2` // $t0 = $t1 + $t2
        - 异常：如果结果超过了32位整型能表示的范围，则会触发算术溢出异常。
    - `ADDI` 指令：格式 `ADDI $dest, $src, immediate`
        
        - 作用：将 `$src` 的值与一个立即数（常量）相加并将结果存储在 `$dest`。
        - 例子：`ADDI $t0, $t1, 100` // $t0 = $t1 + 100
        - 异常：如果结果超过了32位整型能表示的范围，则会触发算术溢出异常。
    - `ADDU` 指令：格式 `ADDU $dest, $src1, $src2`
        
        - 作用：与 `ADD` 相同，但作为无符号加法，不在溢出时触发异常。
        - 例子：`ADDU $t0, $t1, $t2` // $t0 = $t1 + $t2
        - 溢出处理：不检测溢出。
    - `ADDIU` 指令：格式 `ADDIU $dest, $src, immediate`
        
        - 作用：与 `ADDI` 相同，但作为无符号加法，不在溢出时触发异常。
        - 例子：`ADDIU $t0, $t1, 100` // $t0 = $t1 + 100
        - 溢出处理：不检测溢出。
2. **跳转指令详解**
    
    - `BGEZAL` 指令：格式 `BGEZAL $src, offset`
        
        - 作用：如果 `$src` 的值大于等于零，将下一条指令的地址存入 `$ra` 寄存器并跳转到指定 `offset` （相对于当前 PC 的偏移）所指的地址执行指令。
        - 例子：`BGEZAL $t0, 100` // 如果 $t0 >= 0，则跳转
    - `JALR` 指令：格式 `JALR $dest, $src`
        
        - 作用：从 `$src` 指定的地址跳转执行指令，并将返回地址（下一指令地址）存储在 `$dest` 中。
        - 例子：`JALR $ra, $t0` // 跳转到 $t0 的地址，并把返回地址存入 $ra
3. **移位指令详解**
    
    - `SLL` 指令：格式 `SLL $dest, $src, shamt`
        
        - 作用：将 `$src` 向左移动 `shamt` 位数，并将结果存储在 `$dest`。
        - 例子：`SLL $t0, $t1, 2` // $t0 = $t1 << 2
    - `SRL` 指令：格式 `SRL $dest, $src, shamt`
        
        - 作用：将 `$src` 向右逻辑移动 `shamt` 位数，并将结果存储在 `$dest`。
        - 例子：`SRL $t0, $t1, 2` // $t0 = $t1 >> 2 （不保留符号位）
    - `SRA` 指令：格式 `SRA $dest, $src, shamt`
        
        - 作用：将 `$src` 向右算术移动 `shamt` 位数，并将结果存储在 `$dest`。
        - 例子：`SRA $t0, $t1, 2` // $t0 = $t1 >> 2 （保留符号位）
4. **加载与存储指令详解**
    
    - `LW` 指令：格式 `LW $dest, offset($src)`
        
        - 作用：从 `$src` 加上 `offset` 的地址载入一个 32 位字到 `$dest`。
        - 例子：`LW $t0, 100($t1)` // t1 + 100]
    - `SW` 指令：格式 `SW $src, offset($dest)`
        
        - 作用：将 `$src` 寄存器中的 32 位字存储到 `$dest` 加上 `offset` 的地址。
        - 例子：`SW $t0, 100($t1)` // memory[$t1 + 100] = $t0
    - `LB` 指令：格式 `LB $dest, offset($src)`
        
        - 作用：从 `$src` 加上 `offset` 的地址载入一个 8 位字节到 `$dest` 并进行符号扩展。
        - 例子：`LB $t0, 100($t1)` // t1 + 100])
    - `SB` 指令：格式 `SB $src, offset($dest)`
        
        - 作用：将 `$src` 寄存器中的最低 8 位字节存储到 `$dest` 加上 `offset` 的地址。
        - 例子：`SB $t0, 100($t1)` // memory[$t1 + 100] = $t0[7:0]

`JALR` 是MIPS汇编语言的一条指令，代表 "Jump and Link Register"。当执行 `JALR` 指令时，它会跳转到指定寄存器中存储的地址执行程序，同时将返回地址（通常是 `JALR` 指令下一条指令的地址）保存到另一个寄存器中。
指令 `JALR r3,r1` 的意思是：
1. 把 `r1` 寄存器中的内容（也就是跳转地址）加载到程序计数器（PC）中，即跳转到 `r1` 所指定的地址去执行。
2. 将下一条指令的地址保存到 `r3` 中。

根据你提供的信息，`r3` 和 `r1` 初始值都是0。`JALR` 指令执行后的行为将会是：
- `PC`（程序计数器）会被设置为 `r1` 寄存器里的值，根据你的说明，这个值是0。
- `r3` 会被设置为 `JALR` 指令下一条指令的地址。但是，由于我们没有具体的代码位置或地址来确定 `JALR` 指令的具体位置，所以无法具体指出 `r3` 的最终值。

## 有误符号区别
- `lb`（Load Byte）指令用于将内存中的一个8位字节（byte）加载到寄存器中。由于大多数寄存器是32位的，`lb` 会执行符号扩展（sign-extension），这意味着如果加载的字节的最高位（第7位）是1（即这个字节表示一个负数），那么当这个字节被放入32位寄存器时，高24位将被填充为1；如果这个字节的最高位是0，那么高24位将被填充为0。
-  `lw`（Load Word）指令用于将内存中的一个32位字（word）加载到寄存器中。由于它加载的是完整的32位数据，指令本身并不执行符号扩展，因为假定加载的数据已经是正确的32位宽度。




HI和LO的计算方式
```
result = (HI << 64) | LO
```